/*
 * Copyright (C) 2017 HERE Global B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/** @module @here/mapview-decoder **//** */

export abstract class Decoder {

    private readonly eventListeners = new Map<string, (message: any) => void>();

    /**
     * Creates a new Decoder
     */
    constructor() {
    }

    /**
     * Registers an event listener for events that originated in a
     * web worker for a given id. Only one event listener can be set
     * per id.
     *
     * @param id the id to listen to
     * @param callback the callback to invoke for matching events
     */
    public addEventListener(id: string, callback: (message: any) => void) {
        this.eventListeners.set(id, callback);
    }

    /**
     * Removes a previously set event listener for the given id.
     *
     * @param id the id for which to remove the event listeners
     */
    public removeEventListener(id: string) {
        this.eventListeners.delete(id);
    }

    /**
     * Posts a message to a random worker.
     *
     * @param message the message to send
     * @param buffers optional buffers to transfer to the worker
     */
    public abstract postMessage(message: object, buffers?: ArrayBuffer[]): void | never;

    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event the event to dispatch
     */
    protected eventHandler(event: any) {
        if (typeof event.data.type !== "string")
            return; // not an event generated by us, ignore.

        this.dispatchEvent(event.data.type, event);
    }

    private dispatchEvent(id: string, message: any) {
        const callback = this.eventListeners.get(id);
        if (callback === undefined)
            return; // unknown event, ignore.
        callback(message);
    }
}
